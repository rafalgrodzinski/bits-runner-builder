@module drv_keyboard

CMD_PORT u32 <- 0x64
DATA_PORT u32 <- 0x60

CMD_SET_LED u8 <- 0xed
CMD_ECHO u8 <- 0xee
ACK u8 <- 0xfa

LED_SCROLL_LOCK u8 <- 0b0000_0001
LED_NUMBER_LOCK u8 <- 0b0000_0010
LED_CAPS_LOCK u8 <- 0b0000_0100

KEY_L_SHIFT u32 <- 0x2a
KEY_R_SHIFT u32 <- 0x36

ASCII_MAP data<u8> <- {
    '\0', // 0x00 unused
    '\0', // 0x01 esc
    '1',  // 0x02
    '2',  // 0x03
    '3',  // 0x04
    '4',  // 0x05
    '5',  // 0x06
    '6',  // 0x07
    '7',  // 0x08
    '8',  // 0x09
    '9',  // 0x0a
    '0',  // 0x0b
    '-',  // 0x0c
    '=',  // 0x0d
    '\b', // 0x0e
    '\t', // 0x0f
    'q',  // 0x10
    'w',  // 0x11
    'e',  // 0x12
    'r',  // 0x13 
    't',  // 0x14
    'y',  // 0x15
    'u',  // 0x16
    'i',  // 0x17
    'o',  // 0x18
    'p',  // 0x19
    '[',  // 0x1a
    ']',  // 0x1b
    '\n', // 0x1c
    '\0', //0x1d L Ctrl
    'a',  // 0x1e
    's',  // 0x1f
    'd',  // 0x20
    'f',  // 0x21
    'g',  // 0x22
    'h',  // 0x23
    'j',  // 0x24
    'k',  // 0x25
    'l',  // 0x26
    ';',  // 0x27
    '\'', // 0x28
    '`',  // 0x29
    '\0', // 0x2a L Shift
    '\\', // 0x2b
    'z',  // 0x2c
    'x',  // 0x2d
    'c',  // 0x2e
    'v',  // 0x2f
    'b',  // 0x30
    'n',  // 0x31
    'm',  // 0x32
    ',',  // 0x33
    '.',  // 0x34
    '/',  // 0x35
    '\0', // 0x36 R shift
    '\0', // 0x37 ?
    '\0', // 0x38 ?
    ' '   // 0x39
}

SHIFTED_ASCII_MAP data<u8> <- {
    '\0', // 0x00 unused
    '\0', // 0x01 esc
    '!',  // 0x02
    '@',  // 0x03
    '#',  // 0x04
    '$',  // 0x05
    '%',  // 0x06
    '^',  // 0x07
    '&',  // 0x08
    '*',  // 0x09
    '(',  // 0x0a
    ')',  // 0x0b
    '_',  // 0x0c
    '+',  // 0x0d
    '\b', // 0x0e
    '\t', // 0x0f
    'Q',  // 0x10
    'W',  // 0x11
    'E',  // 0x12
    'R',  // 0x13
    'T',  // 0x14
    'Y',  // 0x15
    'U',  // 0x16
    'I',  // 0x17
    'O',  // 0x18
    'P',  // 0x19
    '{',  // 0x1a
    '}',  // 0x1b
    '\n', // 0x1c
    '\0', // 0x1d L Ctrl
    'A',  // 0x1e
    'S',  // 0x1f
    'D',  // 0x20
    'F',  // 0x21
    'G',  // 0x22
    'H',  // 0x23
    'J',  // 0x24
    'K',  // 0x25
    'L',  // 0x26
    ':',  // 0x27
    '\"',  // 0x28
    '~',  // 0x29
    '\0', // 0x2a L Shift
    '|',  // 0x2b
    'Z',  // 0x2c
    'X',  // 0x2d
    'C',  // 0x2e
    'V',  // 0x2f
    'B',  // 0x30
    'N',  // 0x31
    'M',  // 0x32
    '<',  // 0x33
    '>',  // 0x34
    '?',  // 0x35
    '\0', // 0x36 R shift
    '\0', // 0x37 ?
    '\0', // 0x38 ?
    ' '   // 0x39
}

keyboardStatus data<bool, 128>
pressedAscii u8

in raw<"=r,m,~{eax},~{edx}">: portNum u32 -> u8
    mov dx, $1
    in al, dx
    mov $0, al
;

out raw<"m,m,~{eax},~{edx}">: portNum u32, value u8
    mov dx, $0
    mov al, $1
    out dx, al
;

@export handleInterrupt fun
    // check if we have data
    //if in(CMD_PORT) & 0x02.u8 != 1.u8: ret

    scanCode u32 <- in(DATA_PORT)
    isPressed bool <- scanCode & 0x80 = 0
    scanCode <- scanCode & 0x7f // get rid of the flag

    // ignore if there is not status update (eg, repeated key)
    if keyboardStatus[scanCode] = isPressed: ret

    keyboardStatus[scanCode] <- isPressed

    // check range
    if scanCode > ASCII_MAP.count or not isPressed
        pressedAscii <- 0
        ret
    ;

    if scanCode != 0
        isShiftPressed bool <- keyboardStatus[KEY_L_SHIFT] or keyboardStatus[KEY_R_SHIFT]
        pressedAscii <- if isShiftPressed: SHIFTED_ASCII_MAP[scanCode] else: ASCII_MAP[scanCode]
    ;

    if pressedAscii = 'a'.u8
        out(DATA_PORT, CMD_SET_LED)
        out(DATA_PORT, LED_CAPS_LOCK)
        if in(DATA_PORT) != ACK
            out(DATA_PORT, LED_CAPS_LOCK)
        ;
    else
        out(DATA_PORT, CMD_SET_LED)
        out(DATA_PORT, 0.u8)
        if in(DATA_PORT) != ACK
            out(DATA_PORT, 0.u8)
        ;
    ;
;

@export readPressedAscii fun -> u32
    value u32 <- pressedAscii.u32
    pressedAscii <- 0
    ret value
;